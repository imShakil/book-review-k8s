name: Book Review Deployment Pipeline

on:
  push:
    branches:
      - main
      - dev
      - staging
      - prod

  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment (dev, staging, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      cluster_name:
        description: 'Enter full kOps Cluster Name (example: demo-dev.k8s.local)'
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -------------------------
      # Environment Resolution
      # -------------------------
      - name: Extract variables on push
        if: ${{ github.event_name == 'push' }}
        run: |
          if [[ "${{ github.ref_name }}" == "main" || "${{ github.ref_name }}" == "dev" ]]; then
            ENVIRONMENT=dev
            CLUSTER_NAME="${{ vars.KOPS_DEV_CLUSTER_NAME }}"
          elif [[ "${{ github.ref_name }}" == "staging" ]]; then
            ENVIRONMENT=staging
            CLUSTER_NAME="${{ vars.KOPS_STAGING_CLUSTER_NAME }}"
          elif [[ "${{ github.ref_name }}" == "prod" ]]; then
            ENVIRONMENT=prod
            CLUSTER_NAME="${{ vars.KOPS_PROD_CLUSTER_NAME }}"
          else
            echo "Unsupported branch"
            exit 1
          fi

          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV

      - name: Extract workflow_dispatch inputs safely
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          INPUT_ENVIRONMENT: ${{ inputs.environment }}
          INPUT_CLUSTER_NAME: ${{ inputs.cluster_name }}
        run: |
          # Only assign to GITHUB_ENV from controlled env variables
          echo "ENVIRONMENT=$INPUT_ENVIRONMENT" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$INPUT_CLUSTER_NAME" >> $GITHUB_ENV

      - name: Validate environment
        run: |
          if [[ "$ENVIRONMENT" != "dev" && "$ENVIRONMENT" != "staging" && "$ENVIRONMENT" != "prod" ]]; then
            echo "Invalid environment: $ENVIRONMENT"
            exit 1
          fi

          if [[ "$CLUSTER_NAME" == "" ]]; then
            echo "Cluster name is required"
            exit 1
          fi

      # -------------------------
      # Tooling
      # -------------------------
      - name: Install kOps
        run: |
          KOPS_VERSION=$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | jq -r .tag_name)
          curl -Lo kops "https://github.com/kubernetes/kops/releases/download/${KOPS_VERSION}/kops-linux-amd64"
          sudo install -m 0755 kops /usr/local/bin/kops
          kops version --short

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      # -------------------------
      # Cluster Access
      # -------------------------
      - name: Setup Kubernetes Cluster
        run: |
          KOPS_STATE_STORE="s3://${{ vars.S3_BUCKET_NAME }}/${ENVIRONMENT}/clusters/"
          kops export kubeconfig --name "${CLUSTER_NAME}" --state "$KOPS_STATE_STORE" --admin
          kubectl get nodes

      # -------------------------
      # Namespace
      # -------------------------
      - name: Create Namespace
        run: |
          NAMESPACE="book-review-${ENVIRONMENT}"
          kubectl get ns "$NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$NAMESPACE"
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

      # -------------------------
      # Services / LoadBalancers
      # -------------------------
      - name: Create LoadBalancers
        run: |
          kubectl apply -f k8s/services -n ${NAMESPACE}

          echo "Waiting for frontend LoadBalancer..."
          until kubectl get svc frontend -n ${NAMESPACE} \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' | grep -q .; do
            sleep 10
          done

          echo "Waiting for backend LoadBalancer..."
          until kubectl get svc backend -n ${NAMESPACE} \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' | grep -q .; do
            sleep 10
          done

      # -------------------------
      # Runtime Environment Vars
      # -------------------------
      - name: Extract environment variables
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
        run: |
          echo "MYSQL_USER=${MYSQL_USER}" >> $GITHUB_ENV
          echo "MYSQL_PASSWORD=${MYSQL_PASSWORD}" >> $GITHUB_ENV
          echo "MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}" >> $GITHUB_ENV
          echo "MYSQL_DB=${{ vars.MYSQL_DATABASE }}" >> $GITHUB_ENV
          echo "MYSQL_HOST=${{ vars.MYSQL_HOST }}" >> $GITHUB_ENV
          echo "MYSQL_PORT=${{ vars.MYSQL_PORT }}" >> $GITHUB_ENV
          echo "JWT_SECRET=${JWT_SECRET}" >> $GITHUB_ENV
          echo "PROTOCOL="http" >> $GITHUB_ENV

          FRONTEND_LB=$(kubectl get svc frontend -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          BACKEND_LB=$(kubectl get svc backend -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

          echo "ALLOWED_ORIGINS=${PROTOCOL}://${FRONTEND_LB}" >> $GITHUB_ENV
          echo "NEXT_PUBLIC_API_URL=${PROTOCOL}://${BACKEND_LB}" >> $GITHUB_ENV

      # -------------------------
      # Configs & Secrets
      # -------------------------
      - name: Render configs & secrets
        run: |
          envsubst < k8s/configs/app-configs.yml > /tmp/app-configs.yml
          envsubst < k8s/configs/app-secrets.yml > /tmp/app-secrets.yml
          envsubst < k8s/configs/mysql-init.yml > /tmp/mysql-init.yml

          mv /tmp/app-configs.yml k8s/configs/app-configs.yml
          mv /tmp/app-secrets.yml k8s/configs/app-secrets.yml
          mv /tmp/mysql-init.yml k8s/configs/mysql-init.yml

      - name: Apply configs & secrets
        run: |
          kubectl apply -f k8s/configs -n ${NAMESPACE}

      # -------------------------
      # Deployments
      # -------------------------
      - name: Deploy applications
        run: |
          kubectl apply -f k8s/deployments -n ${NAMESPACE}

      - name: Verify rollout
        run: |
          kubectl rollout status deployment/backend -n ${NAMESPACE} --timeout=300s
          kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=300s
          kubectl get pods -n ${NAMESPACE}
          kubectl get svc -n ${NAMESPACE}

      # -------------------------
      # Access Info
      # -------------------------
      - name: Application Access
        run: |
          echo "Frontend: ${PROTOCOL}://$(kubectl get svc frontend -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
          echo "Backend:  ${PROTOCOL}://$(kubectl get svc backend -n ${NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')"
